---
title: 'Core Concepts'
date: '2020-08-07'
---

> Learned from [How to GraphQL official tutorial](https://www.howtographql.com).

## The Schema Definition Language (SDL)

= The syntax for writing schemas

```graphql
type Person {
  name: String!
  age: Int!
  posts: [Post!]!          # array of posts = one-to-many relationship
}

type Post {
  title: String!
  author: Person!
}
```

- Type `Person` has two <span>fields</span> = `name`, `age`
  - `!` after type = field is **required**.

## Fetching data with queries

- GraphQL APIs typically only expose a **single** endpoint.
  - This works because the returned structure of the data is not fixed.
  - It’s completely flexible and lets the client decide what data is actually needed.
- The client needs to send more **information** to the server to express its data needs.
  - = this information is called a <span>query</span>.

### Basic queries

```graphql
{
  allPersons {
    name
  }
}

# return a list of all persons
{
  "allPersons": [
    { "name": "Johnny" },        # each person only has the 'name'
    { "name": "Sarah" },
    { "name": "Alice" }
  ]
}
```

- `allPersons` = **root field** of the query
  - Everything inside the root field = **payload** of the query

```graphql
# allow nested query
{
  allPersons {
    name
    age
    posts {
      title
    }
  }
}
```

### Queries with arguments

Each field can have zero or more arguments if that’s specified in the schema.

```graphql
{
  allPersons(last: 2) {
    name
  }
}
```

## Writing data with mutations

- Changes to the data are made using **mutations**.
- 3 kinds of mutations
  - <span>Creating</span> new data
  - <span>Updating</span> existing data
  - <span>Deleting</span> existing data
- Always need to start with the `mutation` keyword.

```graphql
mutation {
  createPerson(name: "Bob", age: 36) {
    name         # specify a payload to retrieve new data
    age
  }
}

# response
"createPerson": {
  "name": "Bob",
  "age": 36,
}
```

GraphQL types have unique **IDs** that are generated by the server when new objects are created.

```graphql
# Add an id like this
type Person {
  id: ID!
  name: String!
  age: Int!
}

# Directly ask for the id in the payload of the mutation
mutation {
  createPerson(name: "Alice", age: 36) {
    id
  }
}
```

## Realtime updates with subscriptions

<span>Subscriptions</span> : A **realtime** connection to the server to get immediately informed about important events.

- When a client **subscribes** to an event,
  - It will initiate and hold a steady connection to the server.
  - Whenever that particular event then actually happens, the server pushes the corresponding data to the client.
  - Subscriptions represent a **stream** of data sent over to the client, unlike queries and mutations that follow a typical '*request-response-cycle*'.

```graphql
subscription {
  newPerson {
    name
    age
  }
}
```

- A connection is opened between them after a client sent this subscription to a server.
- Then, whenever a new mutation is performed that creates a new `Person`, the server sends the information about this person over to the client like below.

```graphql
{
  "newPerson": {
    "name": "Jane",
    "age": 23
  }
}
```

## Defining a schema

- <span>Schema</span> : Specifies the capabilities of the API and defines how clients can request the data.
  - A **contract** between the server and client.
  - Simply a collection of GraphQL types.
- Special root types : Entry points for the requests sent by the client.
  - `type Query { ... }`
  - `type Mutation { ... }`
  - `type Subscription { ... }`
- To enable the query `allPersons` with `last` argument

```graphql
type Query {
  allPersons(last: Int): [Person!]!
}
```

- To enable the mutation `createPerson` with `name`, `age` arguments

```graphql
type Mutation {
  createPerson(name: String!, age: Int!): Person!
}
```

- To enable the subscription `newPerson`

```graphql
type Subscription {
  newPerson: Person!
}
```